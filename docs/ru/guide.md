# Sure

Библиотека предоставляет механизм кооперативного переключения контекста (нелокальной передачи управления) исполнения для реализации stackful корутин и файберов.

## `ExecutionContext`

Заголовок: `sure/context.hpp`

Сохраненный контекст остановленного исполнения представлен классом [`ExecutionContext`](sure/context.hpp) и включает:
- Регистры процессора
- Контекст санитайзера
- Контекст исключения

## Операции

- _Установка_ (`Setup`) и
- _Переключение_ (`SwitchTo` + `ExitTo`) контекста.

### Переключение контекста

Выглядит так: `current.SwitchTo(target)`

Текущий контекст исполнения будет сохранен в `current`, после чего активируется контекст `target`.

Активируемый контекст `target` 
- либо ранее был сохранен с помощью `SwitchTo` (стоял слева от вызова, в позиции `this`),
- либо был установлен "вручную" с помощью метода `Setup`.

### Установка контекста

Метод `Setup` конструирует **новое исполнение**.  

Метод принимает два аргумента:
- `stack` – диапазон памяти стека, на котором будет работать новое исполнение, в виде `MutableMemView`
- `trampoline` – указатель на реализацию интерфейса [`ITrampoline`](sure/trampoline.hpp) с единственным методом `Run`.

После первого переключения через `SwitchTo` в установленный через `Setup` контекст на стеке `stack` начнется вызов `trampoline->Run()`.

Пример использования: [TinyFibers](https://gitlab.com/Lipovsky/tinyfibers/-/blob/e91c30eefa8779c1443ddd8c0f802930dcaf0b92/tf/rt/fiber.cpp#L43)

### `ITrampoline`

`ITrampoline` представляет для `ExecutionContext` исполняемую сущность (например, файбер или генератор) с методом `Run`.

Вызов `Run` не должен возвращать управление caller-у (т.е. завершаться обычным образом), вместо этого управление должно покидать `Run` с помощью `ExitTo`.

### `ExitTo`

При последнем переключении из контекста (т.е. в конце trampoline корутины / файбера) используйте `ExitTo` вместо `SwitchTo`.

Этот граничный случай необходим для корректной работы проверок в санитайзерах.

## `Stack`

Заголовок: `sure/stack.hpp`

Новый стек аллоцируется с помощью статического конструктора `AllocateBytes(size_t at_least)`:

```cpp
auto stack = Stack::AllocateBytes(at_least);
```

Для выделенного стека будет установлен guard page.

Стек (без учета guard page) будет иметь размер по крайней мере `at_least` байт.

Класс `Stack` владеет выделенной памятью, при разрушении он возвращает ее операционной системе.

С помощью метода `Stack::MutView` можно получить диапазон адресов стека в виде `MutableMemView` 